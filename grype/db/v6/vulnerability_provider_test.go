package v6

import (
	"testing"
	"unicode"
	"unicode/utf8"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"

	"github.com/anchore/grype/grype/distro"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/pkg/qualifier"
	"github.com/anchore/grype/grype/search"
	"github.com/anchore/grype/grype/version"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft/cpe"
)

func Test_FindVulnerabilitiesByDistro(t *testing.T) {
	provider := testVulnerabilityProvider(t)

	d, err := distro.New(distro.Debian, "8", "")
	require.NoError(t, err)

	p := pkg.Package{
		ID:   pkg.ID(uuid.NewString()),
		Name: "neutron",
	}

	actual, err := provider.FindVulnerabilities(search.ByDistro(*d), search.ByPackageName(p.Name))
	require.NoError(t, err)

	expected := []vulnerability.Vulnerability{
		{
			PackageName: "neutron",
			Constraint:  version.MustGetConstraint("< 2014.1.3-6", version.DebFormat),
			Reference: vulnerability.Reference{
				ID:        "CVE-2014-fake-1",
				Namespace: "debian:distro:debian:8",
			},
			PackageQualifiers: []qualifier.Qualifier{},
			CPEs:              nil,
			Advisories:        []vulnerability.Advisory{},
			Metadata: &vulnerability.Metadata{
				ID:          "CVE-2014-fake-1",
				DataSource:  "http://somewhere/CVE-2014-fake-1",
				Namespace:   "debian:distro:debian:8",
				Severity:    "High",
				URLs:        nil,
				Description: "CVE-2014-fake-1-description",
			},
		},
		{
			PackageName: "neutron",
			Constraint:  version.MustGetConstraint("< 2013.0.2-1", version.DebFormat),
			Reference: vulnerability.Reference{
				ID:        "CVE-2013-fake-2",
				Namespace: "debian:distro:debian:8",
			},
			PackageQualifiers: []qualifier.Qualifier{},
			CPEs:              nil,
			Advisories:        []vulnerability.Advisory{},
			Metadata: &vulnerability.Metadata{
				ID:          "CVE-2013-fake-2",
				DataSource:  "http://somewhere/CVE-2013-fake-2",
				Namespace:   "debian:distro:debian:8",
				Severity:    "High",
				URLs:        nil,
				Description: "CVE-2013-fake-2-description",
			},
		},
	}

	require.Len(t, actual, len(expected))

	for idx, vuln := range actual {
		if d := cmp.Diff(expected[idx], vuln, cmpOpts()...); d != "" {
			t.Errorf("diff: %+v", d)
		}
	}
}

func Test_FindVulnerabilitiesByEmptyDistro(t *testing.T) {
	provider := testVulnerabilityProvider(t)

	p := pkg.Package{
		ID:   pkg.ID(uuid.NewString()),
		Name: "neutron",
	}

	vulnerabilities, err := provider.FindVulnerabilities(search.ByDistro(distro.Distro{}), search.ByPackageName(p.Name))

	require.Empty(t, vulnerabilities)
	require.NoError(t, err)
}

func Test_FindVulnerabilitiesByCPE(t *testing.T) {

	tests := []struct {
		name     string
		cpe      cpe.CPE
		expected []vulnerability.Vulnerability
		err      bool
	}{
		{
			name: "match from name and target SW",
			cpe:  cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:*:*:*:ruby:*:*", ""),
			expected: []vulnerability.Vulnerability{
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.4", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-4",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:something:*:*:ruby:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-4",
						DataSource:  "http://somewhere/CVE-2014-fake-4",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-4-description",
					},
				},
			},
		},
		{
			name: "match with normalization",
			cpe:  cpe.Must("cpe:2.3:*:ActiVERecord:ACTiveRecord:*:*:*:*:*:ruby:*:*", ""),
			expected: []vulnerability.Vulnerability{
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.4", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-4",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:something:*:*:ruby:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-4",
						DataSource:  "http://somewhere/CVE-2014-fake-4",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-4-description",
					},
				},
			},
		},
		{
			name: "match from vendor & name",
			cpe:  cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:*:*:*:*:*:*", ""),
			expected: []vulnerability.Vulnerability{
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.6", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-3",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:*:*:*:rails:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-3",
						DataSource:  "http://somewhere/CVE-2014-fake-3",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-3-description",
					},
				},
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.4", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-4",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:something:*:*:ruby:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-4",
						DataSource:  "http://somewhere/CVE-2014-fake-4",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-4-description",
					},
				},
			},
		},
		{
			name: "allow query with only product",
			cpe:  cpe.Must("cpe:2.3:a:*:product:*:*:*:*:*:*:*:*", ""),
		},
		{
			name: "do not allow query without product",
			cpe: cpe.CPE{
				Attributes: cpe.Attributes{
					Part:   "a",
					Vendor: "v",
				},
			},
			err: true,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			provider := testVulnerabilityProvider(t)

			actual, err := provider.FindVulnerabilities(search.ByCPE(test.cpe))
			if err != nil && !test.err {
				t.Fatalf("expected no err, got: %+v", err)
			} else if err == nil && test.err {
				t.Fatalf("expected an err, gots" +
					" none")
			}

			require.Len(t, actual, len(test.expected))

			for idx, vuln := range actual {
				if d := cmp.Diff(test.expected[idx], vuln, cmpOpts()...); d != "" {
					t.Errorf("diff: %+v", d)
				}
			}
		})
	}

}

func Test_FindVulnerabilitiesByByID(t *testing.T) {
	provider := testVulnerabilityProvider(t)

	d, err := distro.New(distro.Debian, "8", "")
	require.NoError(t, err)

	// with distro
	actual, err := provider.FindVulnerabilities(search.ByDistro(*d), search.ByID("CVE-2014-fake-1"))
	require.NoError(t, err)

	expected := []vulnerability.Vulnerability{
		{
			Reference: vulnerability.Reference{
				ID:        "CVE-2014-fake-1",
				Namespace: "debian:distro:debian:8",
			},
			PackageName:       "neutron",
			Constraint:        version.MustGetConstraint("< 2014.1.3-6", version.DebFormat),
			PackageQualifiers: []qualifier.Qualifier{},
			CPEs:              nil,
			Advisories:        []vulnerability.Advisory{},
			Metadata: &vulnerability.Metadata{
				ID:          "CVE-2014-fake-1",
				DataSource:  "http://somewhere/CVE-2014-fake-1",
				Namespace:   "debian:distro:debian:8",
				Severity:    "High",
				URLs:        nil,
				Description: "CVE-2014-fake-1-description",
			},
		},
	}

	require.Len(t, actual, len(expected))

	for idx, vuln := range actual {
		if d := cmp.Diff(expected[idx], vuln, cmpOpts()...); d != "" {
			t.Errorf("diff: %+v", d)
		}
	}

	// without distro
	actual, err = provider.FindVulnerabilities(search.ByID("CVE-2014-fake-1"))
	require.NoError(t, err)

	for idx, vuln := range actual {
		if d := cmp.Diff(expected[idx], vuln, cmpOpts()...); d != "" {
			t.Errorf("diff: %+v", d)
		}
	}

	// prove we survive a bad request
	actual, err = provider.FindVulnerabilities(search.ByDistro(*d), search.ByID("CVE-2014-fake-3"))
	require.NoError(t, err)
	require.Empty(t, actual)
}

func Test_DataSource(t *testing.T) {
	tests := []struct {
		name     string
		vuln     VulnerabilityHandle
		expected vulnerability.Metadata
	}{
		{
			name: "no reference urls",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: nil,
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "",
				URLs:       nil,
			},
		},
		{
			name: "one reference url",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: []Reference{
						{
							URL: "url1",
						},
					},
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "url1",
				URLs:       nil,
			},
		},
		{
			name: "two reference urls",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: []Reference{
						{
							URL: "url1",
						},
						{
							URL: "url2",
						},
					},
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "url1",
				URLs:       []string{"url2"},
			},
		},
		{
			name: "many reference urls",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: []Reference{
						{
							URL: "url4",
						},
						{
							URL: "url3",
						},
						{
							URL: "url2",
						},
						{
							URL: "url1",
						},
					},
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "url4",
				URLs:       []string{"url3", "url2", "url1"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := newVulnerabilityMetadata(&tt.vuln, "", nil, nil)
			got.Severity = ""
			require.NoError(t, err)
			if diff := cmp.Diff(&tt.expected, got, cmpOpts()...); diff != "" {
				t.Fatal(diff)
			}
		})
	}
}

func cmpOpts() []cmp.Option {
	return []cmp.Option{
		// globally ignore unexported -- these are unexported structs we cannot reference here to use cmpopts.IgnoreUnexported
		cmp.FilterPath(func(p cmp.Path) bool {
			sf, ok := p.Index(-1).(cmp.StructField)
			if !ok {
				return false
			}
			r, _ := utf8.DecodeRuneInString(sf.Name())
			return !unicode.IsUpper(r)
		}, cmp.Ignore()),
		cmpopts.EquateEmpty(),
		cmpopts.IgnoreFields(vulnerability.Reference{}, "Internal"),
	}
}
