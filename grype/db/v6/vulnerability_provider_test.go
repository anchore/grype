package v6

import (
	"testing"
	"unicode"
	"unicode/utf8"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"

	"github.com/anchore/grype/grype/distro"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/pkg/qualifier"
	"github.com/anchore/grype/grype/search"
	"github.com/anchore/grype/grype/version"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft/cpe"
	syftPkg "github.com/anchore/syft/syft/pkg"
)

func Test_FindVulnerabilitiesByDistro(t *testing.T) {
	provider := testVulnerabilityProvider(t)

	d, err := distro.New(distro.Debian, "8", "")
	require.NoError(t, err)

	p := pkg.Package{
		ID:      pkg.ID(uuid.NewString()),
		Name:    "neutron",
		Version: "1.0.0",
		Type:    syftPkg.DebPkg,
	}

	actual, err := provider.FindVulnerabilities(search.ByDistro(*d), search.ByPackageName(p.Name), search.ByVersion(*version.NewVersionFromPkg(p)))
	require.NoError(t, err)

	expected := []vulnerability.Vulnerability{
		{
			PackageName: "neutron",
			Constraint:  version.MustGetConstraint("< 2014.1.3-6", version.DebFormat),
			Reference: vulnerability.Reference{
				ID:        "CVE-2014-fake-1",
				Namespace: "debian:distro:debian:8",
			},
			PackageQualifiers: []qualifier.Qualifier{},
			CPEs:              nil,
			Advisories:        []vulnerability.Advisory{},
			Metadata: &vulnerability.Metadata{
				ID:          "CVE-2014-fake-1",
				DataSource:  "http://somewhere/CVE-2014-fake-1",
				Namespace:   "debian:distro:debian:8",
				Severity:    "High",
				URLs:        nil,
				Description: "CVE-2014-fake-1-description",
			},
			RelatedVulnerabilities: []vulnerability.Reference{{ID: "CVE-2014-fake-1", Namespace: "nvd:cpe"}},
		},
		{
			PackageName: "neutron",
			Constraint:  version.MustGetConstraint("< 2013.0.2-1", version.DebFormat),
			Reference: vulnerability.Reference{
				ID:        "CVE-2013-fake-2",
				Namespace: "debian:distro:debian:8",
			},
			PackageQualifiers: []qualifier.Qualifier{},
			CPEs:              nil,
			Advisories:        []vulnerability.Advisory{},
			Metadata: &vulnerability.Metadata{
				ID:          "CVE-2013-fake-2",
				DataSource:  "http://somewhere/CVE-2013-fake-2",
				Namespace:   "debian:distro:debian:8",
				Severity:    "High",
				URLs:        nil,
				Description: "CVE-2013-fake-2-description",
			},
			RelatedVulnerabilities: []vulnerability.Reference{{ID: "CVE-2013-fake-2", Namespace: "nvd:cpe"}},
		},
	}

	require.Len(t, actual, len(expected))

	for idx, vuln := range actual {
		if d := cmp.Diff(expected[idx], vuln, cmpOpts()...); d != "" {
			t.Errorf("diff: %+v", d)
		}
	}
}

func Test_FindVulnerabilitiesByEmptyDistro(t *testing.T) {
	provider := testVulnerabilityProvider(t)

	p := pkg.Package{
		ID:   pkg.ID(uuid.NewString()),
		Name: "neutron",
	}

	vulnerabilities, err := provider.FindVulnerabilities(search.ByDistro(distro.Distro{}), search.ByPackageName(p.Name))

	require.Empty(t, vulnerabilities)
	require.NoError(t, err)
}

func Test_FindVulnerabilitiesByCPE(t *testing.T) {

	tests := []struct {
		name     string
		cpe      cpe.CPE
		expected []vulnerability.Vulnerability
		err      bool
	}{
		{
			name: "match from name and target SW",
			cpe:  cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:*:*:*:ruby:*:*", ""),
			expected: []vulnerability.Vulnerability{
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.4", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-4",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:something:*:*:ruby:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-4",
						DataSource:  "http://somewhere/CVE-2014-fake-4",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-4-description",
					},
				},
			},
		},
		{
			name: "match with normalization",
			cpe:  cpe.Must("cpe:2.3:*:ActiVERecord:ACTiveRecord:*:*:*:*:*:ruby:*:*", ""),
			expected: []vulnerability.Vulnerability{
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.4", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-4",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:something:*:*:ruby:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-4",
						DataSource:  "http://somewhere/CVE-2014-fake-4",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-4-description",
					},
				},
			},
		},
		{
			name: "match from vendor & name",
			cpe:  cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:*:*:*:*:*:*", ""),
			expected: []vulnerability.Vulnerability{
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.6", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-3",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:*:*:*:rails:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-3",
						DataSource:  "http://somewhere/CVE-2014-fake-3",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-3-description",
					},
				},
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 3.7.4", version.UnknownFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-4",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:something:*:*:ruby:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-4",
						DataSource:  "http://somewhere/CVE-2014-fake-4",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-4-description",
					},
				},
				{
					PackageName: "activerecord",
					Constraint:  version.MustGetConstraint("< 70.3.0-rc0", version.ApkFormat),
					Reference: vulnerability.Reference{
						ID:        "CVE-2014-fake-7",
						Namespace: "nvd:cpe",
					},
					CPEs: []cpe.CPE{
						cpe.Must("cpe:2.3:*:activerecord:activerecord:*:*:*:*:*:rails:*:*", ""),
					},
					PackageQualifiers: []qualifier.Qualifier{},
					Advisories:        []vulnerability.Advisory{},
					Metadata: &vulnerability.Metadata{
						ID:          "CVE-2014-fake-7",
						DataSource:  "http://somewhere/CVE-2014-fake-7",
						Namespace:   "nvd:cpe",
						Severity:    "High",
						URLs:        nil,
						Description: "CVE-2014-fake-7-description",
					},
				},
			},
		},
		{
			name: "allow query with only product",
			cpe:  cpe.Must("cpe:2.3:a:*:product:*:*:*:*:*:*:*:*", ""),
		},
		{
			name: "do not allow query without product",
			cpe: cpe.CPE{
				Attributes: cpe.Attributes{
					Part:   "a",
					Vendor: "v",
				},
			},
			err: true,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			provider := testVulnerabilityProvider(t)

			actual, err := provider.FindVulnerabilities(search.ByCPE(test.cpe))
			if err != nil && !test.err {
				t.Fatalf("expected no err, got: %+v", err)
			} else if err == nil && test.err {
				t.Fatalf("expected an err, gots" +
					" none")
			}

			require.Len(t, actual, len(test.expected))

			for idx, vuln := range actual {
				if d := cmp.Diff(test.expected[idx], vuln, cmpOpts()...); d != "" {
					t.Errorf("diff: %+v", d)
				}
			}
		})
	}

}

func Test_FindVulnerabilitiesByID(t *testing.T) {
	provider := testVulnerabilityProvider(t)

	d, err := distro.New(distro.Debian, "8", "")
	require.NoError(t, err)

	// with distro
	actual, err := provider.FindVulnerabilities(search.ByDistro(*d), search.ByID("CVE-2014-fake-1"))
	require.NoError(t, err)

	expected := []vulnerability.Vulnerability{
		{
			Reference: vulnerability.Reference{
				ID:        "CVE-2014-fake-1",
				Namespace: "debian:distro:debian:8",
			},
			PackageName:       "neutron",
			Constraint:        version.MustGetConstraint("< 2014.1.3-6", version.DebFormat),
			PackageQualifiers: []qualifier.Qualifier{},
			CPEs:              nil,
			Advisories:        []vulnerability.Advisory{},
			Metadata: &vulnerability.Metadata{
				ID:          "CVE-2014-fake-1",
				DataSource:  "http://somewhere/CVE-2014-fake-1",
				Namespace:   "debian:distro:debian:8",
				Severity:    "High",
				URLs:        nil,
				Description: "CVE-2014-fake-1-description",
			},
			RelatedVulnerabilities: []vulnerability.Reference{{ID: "CVE-2014-fake-1", Namespace: "nvd:cpe"}},
		},
	}

	require.Len(t, actual, len(expected))

	for idx, vuln := range actual {
		if d := cmp.Diff(expected[idx], vuln, cmpOpts()...); d != "" {
			t.Errorf("diff: %+v", d)
		}
	}

	// without distro
	actual, err = provider.FindVulnerabilities(search.ByID("CVE-2014-fake-1"))
	require.NoError(t, err)

	for idx, vuln := range actual {
		if d := cmp.Diff(expected[idx], vuln, cmpOpts()...); d != "" {
			t.Errorf("diff: %+v", d)
		}
	}
}

func Test_FindVulnerabilitiesByEcosystem_UnknownPackageType(t *testing.T) {
	tests := []struct {
		name        string
		packageName string
		packageType syftPkg.Type
		language    syftPkg.Language
		expectedIDs []string
	}{
		{
			name:        "known package type",
			packageName: "Newtonsoft.Json",
			packageType: syftPkg.DotnetPkg,
			language:    syftPkg.Java, // deliberately wrong to prove we're using package type
			expectedIDs: []string{"GHSA-5crp-9r3c-p9vr"},
		},
		{
			name:        "unknown package type, known language",
			packageName: "Newtonsoft.Json",
			packageType: syftPkg.UnknownPkg,
			language:    syftPkg.Dotnet,
			expectedIDs: []string{"GHSA-5crp-9r3c-p9vr"},
		},
		{
			name:        "unknown package type, unknown language",
			packageName: "Newtonsoft.Json",
			packageType: syftPkg.UnknownPkg,
			language:    syftPkg.UnknownLanguage,
			// The vuln GHSA-5crp-9r3c-p9vr is specifically associated
			// with the dotnet ecosystem, so it should not be returned here.
			// In a real search for UnknownPkg + UnknownLanguage, there should
			// be a separate search.ByCPE run that _does_ return it.
			expectedIDs: []string{},
		},
	}
	provider := testVulnerabilityProvider(t)
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual, err := provider.FindVulnerabilities(
				search.ByEcosystem(test.language, test.packageType),
				search.ByPackageName(test.packageName),
			)
			require.NoError(t, err)
			actualIDs := make([]string, len(actual))
			for idx, vuln := range actual {
				actualIDs[idx] = vuln.ID
			}
			if d := cmp.Diff(test.expectedIDs, actualIDs); d != "" {
				t.Errorf("diff: %+v", d)
			}
		})
	}
}

func Test_DataSource(t *testing.T) {
	tests := []struct {
		name     string
		vuln     VulnerabilityHandle
		expected vulnerability.Metadata
	}{
		{
			name: "no reference urls",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: nil,
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "",
				URLs:       nil,
			},
		},
		{
			name: "one reference url",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: []Reference{
						{
							URL: "url1",
						},
					},
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "url1",
				URLs:       nil,
			},
		},
		{
			name: "two reference urls",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: []Reference{
						{
							URL: "url1",
						},
						{
							URL: "url2",
						},
					},
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "url1",
				URLs:       []string{"url2"},
			},
		},
		{
			name: "many reference urls",
			vuln: VulnerabilityHandle{
				BlobValue: &VulnerabilityBlob{
					References: []Reference{
						{
							URL: "url4",
						},
						{
							URL: "url3",
						},
						{
							URL: "url2",
						},
						{
							URL: "url1",
						},
					},
				},
			},
			expected: vulnerability.Metadata{
				DataSource: "url4",
				URLs:       []string{"url3", "url2", "url1"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := newVulnerabilityMetadata(&tt.vuln, "", nil, nil)
			got.Severity = ""
			require.NoError(t, err)
			if diff := cmp.Diff(&tt.expected, got, cmpOpts()...); diff != "" {
				t.Fatal(diff)
			}
		})
	}
}

func Test_filterAffectedPackageRanges(t *testing.T) {
	tests := []struct {
		name                     string
		ranges                   []AffectedRange
		matchesConstraint        func(constraint version.Constraint) (bool, error)
		expectedAllRangesRemoved bool
		expectedUnmatchedStrings []string
	}{
		{
			name:                     "no ranges",
			ranges:                   nil,
			expectedAllRangesRemoved: false, // important! we assume that a vulnerability with no ranges is always vulnerable
			expectedUnmatchedStrings: nil,
		},
		{
			name: "has ranges within constraint",
			ranges: []AffectedRange{
				{
					Version: AffectedVersion{
						Type:       "rpm",
						Constraint: "< 1.0.0",
					},
				},
				{
					Version: AffectedVersion{
						Type:       "rpm",
						Constraint: "< 2.0.0",
					},
				},
			},
			matchesConstraint: func(constraint version.Constraint) (bool, error) {
				return true, nil
			},
			expectedAllRangesRemoved: false,
			expectedUnmatchedStrings: nil,
		},
		{
			name: "has ranges outside constraint",
			ranges: []AffectedRange{
				{
					Version: AffectedVersion{
						Type:       "rpm",
						Constraint: "< 1.0.0",
					},
				},
				{
					Version: AffectedVersion{
						Type:       "rpm",
						Constraint: "< 2.0.0",
					},
				},
			},
			matchesConstraint: func(constraint version.Constraint) (bool, error) {
				return false, nil
			},
			expectedAllRangesRemoved: true,
			expectedUnmatchedStrings: []string{"< 1.0.0", "< 2.0.0"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockMatcher := &mockVersionConstraintMatcher{
				matchesConstraintFunc: tt.matchesConstraint,
			}

			blob := &AffectedPackageBlob{
				Ranges: tt.ranges,
			}

			allRangesRemoved, unmatchedConstraints := filterAffectedPackageRanges(mockMatcher, blob)

			require.Equal(t, tt.expectedAllRangesRemoved, allRangesRemoved)
			require.Equal(t, tt.expectedUnmatchedStrings, unmatchedConstraints)
		})
	}
}

type mockVersionConstraintMatcher struct {
	matchesConstraintFunc func(constraint version.Constraint) (bool, error)
}

func (m *mockVersionConstraintMatcher) MatchesConstraint(constraint version.Constraint) (bool, error) {
	if m.matchesConstraintFunc != nil {
		return m.matchesConstraintFunc(constraint)
	}
	return false, nil
}

func cmpOpts() []cmp.Option {
	return []cmp.Option{
		// globally ignore unexported -- these are unexported structs we cannot reference here to use cmpopts.IgnoreUnexported
		cmp.FilterPath(func(p cmp.Path) bool {
			sf, ok := p.Index(-1).(cmp.StructField)
			if !ok {
				return false
			}
			r, _ := utf8.DecodeRuneInString(sf.Name())
			return !unicode.IsUpper(r)
		}, cmp.Ignore()),
		cmpopts.EquateEmpty(),
		cmpopts.IgnoreFields(vulnerability.Reference{}, "Internal"),
	}
}
