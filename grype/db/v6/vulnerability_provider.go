package v6

import (
	"errors"
	"fmt"
	"io"
	"strconv"

	"github.com/iancoleman/strcase"
	"gorm.io/gorm"

	"github.com/anchore/grype/grype/db/internal/gormadapter"
	v5 "github.com/anchore/grype/grype/db/v5"
	"github.com/anchore/grype/grype/distro"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/grype/internal/log"
	"github.com/anchore/syft/syft/cpe"
	syftPkg "github.com/anchore/syft/syft/pkg"
)

func NewVulnerabilityProvider(rdr Reader) vulnerability.Provider {
	return &vulnerabilityProvider{
		db:        getDB(rdr),
		providers: map[string]*Provider{},
		reader:    rdr,
	}
}

func getDB(rdr Reader) *gorm.DB {
	return rdr.(gormadapter.GetDB).GetDB()
}

type vulnerabilityProvider struct {
	db        *gorm.DB
	providers map[string]*Provider
	reader    Reader
}

func (s vulnerabilityProvider) Get(id, _ string) ([]vulnerability.Vulnerability, error) {
	return s.FindVulnerabilities(NewIDCriteria(id))
}

func (s vulnerabilityProvider) GetByDistro(d *distro.Distro, p pkg.Package) ([]vulnerability.Vulnerability, error) {
	return s.FindVulnerabilities(
		NewPackageNameCriteria(p.Name),
		NewDistroCriteria(d),
	)
}

func (s vulnerabilityProvider) GetByLanguage(language syftPkg.Language, p pkg.Package) ([]vulnerability.Vulnerability, error) {
	return s.FindVulnerabilities(
		NewPackageNameCriteria(p.Name),
		NewLanguageCriteria(&language),
	)
}

func (s vulnerabilityProvider) VulnerabilityMetadata(ref vulnerability.Reference) (*vulnerability.Metadata, error) {
	vuln, ok := ref.Internal.(*VulnerabilityHandle)
	if !ok {
		return nil, fmt.Errorf("no vuln ID found")
	}
	return &vulnerability.Metadata{
		ID:          vuln.Name,
		DataSource:  vuln.Provider.ID,
		Namespace:   "",
		Severity:    toSeverityString(vuln),
		URLs:        toURLs(vuln),
		Description: vuln.BlobValue.Description,
		Cvss:        NewCvss(vuln.BlobValue.Severities...),
	}, nil
}

func (s vulnerabilityProvider) GetMetadata(id string, namespace string) (*vulnerability.Metadata, error) {
	log.Warnf("GetMetadata(id,namespace) is deprecated and will likely give incorrect results when invoked against a v6 database")
	vulns, err := s.reader.GetVulnerabilities(&VulnerabilitySpecifier{
		Name: id,
	}, &GetVulnerabilityOptions{
		Preload: true,
	})
	if len(vulns) == 0 || err != nil {
		return nil, err
	}
	vuln := &vulns[0]
	return &vulnerability.Metadata{
		ID:          vuln.Name,
		DataSource:  vuln.Provider.ID,
		Namespace:   namespace, // FIXME -- setting this to the caller provided namespace is probably wrong
		Severity:    toSeverityString(vuln),
		URLs:        toURLs(vuln),
		Description: vuln.BlobValue.Description,
		Cvss:        NewCvss(vuln.BlobValue.Severities...),
	}, nil
}

func (s vulnerabilityProvider) Close() error {
	return s.reader.(io.Closer).Close()
}

func (s vulnerabilityProvider) GetRules(_ string) ([]match.IgnoreRule, error) {
	return nil, nil
}

func (s vulnerabilityProvider) GetByCPE(c cpe.CPE) ([]vulnerability.Vulnerability, error) {
	return s.FindVulnerabilities(NewCPECriteria(&c))
}

//nolint:funlen,gocognit
func (s vulnerabilityProvider) FindVulnerabilities(crit ...vulnerability.Criteria) ([]vulnerability.Vulnerability, error) {
	var errs error
	var out []vulnerability.Vulnerability

	c := vulnerabilityCriteria{}
	for _, cri := range crit {
		vc, ok := cri.(*vulnerabilityCriteria)
		if !ok {
			continue
		}
		if vc.p.Name != "" {
			c.p.Name = vc.p.Name
		}
		if vc.distro != nil {
			c.distro = vc.distro
		}
		if vc.language != nil {
			c.language = vc.language
		}
		if vc.cpe != nil {
			c.cpe = vc.cpe
		}
		if vc.id != "" {
			c.id = vc.id
		}
	}

	if c.id != "" {
		handles, err := s.reader.GetAffectedPackages(&PackageSpecifier{}, &GetAffectedPackageOptions{
			Vulnerabilities: []VulnerabilitySpecifier{
				{
					Name: c.id,
				},
			},
		})
		if err != nil {
			return nil, err
		}

		return s.toVulns(c.p.Name, handles, nil)
	}

	var affectedPackages []AffectedPackageHandle
	var affectedCPEs []AffectedCPEHandle

	// when searching by CPEs, we need to look for
	if c.cpe != nil {
		cp := c.cpe
		pkgs, err := s.reader.GetAffectedPackages(&PackageSpecifier{
			CPE: &cp.Attributes,
		}, &GetAffectedPackageOptions{
			PreloadVulnerability: false,
		})
		if err != nil {
			return nil, err
		}

		affectedPackages = append(affectedPackages, pkgs...)

		cpes, err := s.reader.GetAffectedCPEs(&cp.Attributes, &GetAffectedCPEOptions{
			PreloadCPE:           true,
			PreloadVulnerability: false,
		})
		if err != nil {
			return nil, err
		}

		affectedCPEs = append(affectedCPEs, cpes...)
	}

	if c.language != nil && *c.language != "" {
		pkgs, err := s.reader.GetAffectedPackages(&PackageSpecifier{
			Name: c.p.Name,
			Type: string(*c.language),
		}, &GetAffectedPackageOptions{
			PreloadOS:            false,
			PreloadPackage:       false,
			PreloadPackageCPEs:   false,
			PreloadVulnerability: false,
			PreloadBlob:          false,
			OSs:                  nil,
			Vulnerabilities:      nil,
		})
		if err != nil {
			return nil, err
		}

		affectedPackages = append(affectedPackages, pkgs...)
	}

	if c.distro != nil {
		d := c.distro
		minorVersion := ""
		if d.Version != nil {
			segs := d.Version.Segments()
			if len(segs) > 1 {
				minorVersion = strconv.Itoa(segs[1])
			}
		}
		pkgs, err := s.reader.GetAffectedPackages(&PackageSpecifier{
			Name: c.p.Name,
		}, &GetAffectedPackageOptions{
			OSs: []*OSSpecifier{
				{
					Name:          d.Name(),
					MajorVersion:  d.MajorVersion(),
					MinorVersion:  minorVersion,
					LabelVersion:  "",
					AllowMultiple: true, // TODO it's unclear when/why I choose this option
				},
			},
		})
		if err != nil {
			return nil, err
		}

		affectedPackages = append(affectedPackages, pkgs...)
	}

	// after filtering, read vulnerability data
	if err := fillAffectedPackageHandles(s.db, ptrs(affectedPackages)); err != nil {
		return nil, err
	}

	vulns, err := s.toVulns(c.p.Name, affectedPackages, affectedCPEs)
	if err != nil {
		errs = errors.Join(errs, err)
	}
	out = append(out, vulns...)

	return out, errs
}

// func isEmpty(o any) bool {
//	v := reflect.ValueOf(o)
//	return !v.IsValid() || !v.IsZero()
//}

func toSeverityString(vuln *VulnerabilityHandle) string {
	return strcase.ToCamel(getSeverity(vuln).String())
}

func getSeverity(vuln *VulnerabilityHandle) vulnerability.Severity {
	if vuln.BlobValue == nil {
		return vulnerability.UnknownSeverity
	}
	if len(vuln.BlobValue.Severities) > 0 {
		return extractSeverity(vuln.BlobValue.Severities[0].Value)
	}
	return vulnerability.UnknownSeverity
}

func extractSeverity(severity any) vulnerability.Severity {
	switch sev := severity.(type) {
	case CVSSSeverity:
		return normalizedScoreToSeverityValue(sev.Score / 10.)
	default:
		return vulnerability.UnknownSeverity
	}
}

func normalizedScoreToSeverityValue(score float64) vulnerability.Severity {
	if score > .9 {
		return vulnerability.CriticalSeverity
	}
	if score > .7 {
		return vulnerability.HighSeverity
	}
	if score > .4 {
		return vulnerability.MediumSeverity
	}
	if score > .2 {
		return vulnerability.LowSeverity
	}
	if score >= .0 {
		return vulnerability.NegligibleSeverity
	}
	return vulnerability.UnknownSeverity
}

func toURLs(vuln *VulnerabilityHandle) []string {
	var out []string
	for _, v := range vuln.BlobValue.References {
		out = append(out, v.URL)
	}
	return out
}

func (s vulnerabilityProvider) toVulns(packageName string, packageHandles []AffectedPackageHandle, cpeHandles []AffectedCPEHandle) ([]vulnerability.Vulnerability, error) {
	var out []vulnerability.Vulnerability

	// ensure all data we need is filled out
	packageHandlePtrs := ptrs(packageHandles)
	if err := errors.Join(
		fillAffectedPackageHandles(s.db, packageHandlePtrs),
		s.fillVulnerabilityHandles(affectedPackageVulnerabilityHandles(packageHandlePtrs)),
	); err != nil {
		return nil, err
	}

	cpeHandlePtrs := ptrs(cpeHandles)
	if err := errors.Join(
		s.fillAffectedCPEHandles(cpeHandlePtrs),
		s.fillVulnerabilityHandles(affectedCPEVulnerabilityHandles(cpeHandlePtrs)),
	); err != nil {
		return nil, err
	}

	for _, packageHandle := range packageHandles {
		if packageHandle.BlobValue == nil {
			log.Debugf("unable to find blobValue for %+v", packageHandle)
			continue
		}
		for _, rng := range packageHandle.BlobValue.Ranges {
			v, err := NewVulnerabilityFromAffectedPackageHandle(s.reader, packageHandle, rng)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			out = append(out, *v)
		}
	}

	if err := s.fillVulnerabilityHandles(affectedCPEVulnerabilityHandles(ptrs(cpeHandles))); err != nil {
		return out, err
	}

	for _, c := range cpeHandles {
		if c.BlobValue == nil {
			log.Debugf("unable to find blobValue for %+v", c)
			continue
		}
		for _, rng := range c.BlobValue.Ranges {
			v, err := NewVulnerabilityFromAffectedCPEHandle(s.reader, packageName, c, rng)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			out = append(out, *v)
		}
	}

	return out, nil
}

func (s vulnerabilityProvider) fillProviders(handles []*VulnerabilityHandle) error {
	if len(s.providers) == 0 {
		var providers []*Provider
		tx := s.db.Find(&providers)
		if tx.Error != nil {
			return tx.Error
		}
		for _, p := range providers {
			s.providers[p.ID] = p
		}
	}

	for _, h := range handles {
		h.Provider = s.providers[h.ProviderID]
	}

	return nil
}

var _ interface {
	v5.VulnerabilityProvider
	vulnerability.Provider
	vulnerability.MetadataProvider
	match.ExclusionProvider
	io.Closer
} = (*vulnerabilityProvider)(nil)
