package v6

import (
	"errors"
	"fmt"
	"io"
	"iter"

	"github.com/iancoleman/strcase"
	"gorm.io/gorm"

	"github.com/anchore/grype/grype/db/internal/gormadapter"
	"github.com/anchore/grype/grype/version"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/grype/internal/log"
	"github.com/anchore/syft/syft/cpe"
)

func NewVulnerabilityProvider(rdr Reader) vulnerability.Provider {
	return &vulnerabilityProvider{
		db:        getDB(rdr),
		providers: map[string]*Provider{},
		reader:    rdr,
	}
}

func getDB(rdr Reader) *gorm.DB {
	return rdr.(gormadapter.GetDB).GetDB()
}

type vulnerabilityProvider struct {
	db        *gorm.DB
	providers map[string]*Provider
	reader    Reader
}

// func (s vulnerabilityProvider) Get(id, _ string) ([]vulnerability.Vulnerability, error) {
//	return s.FindVulnerabilities(NewIDCriteria(id))
//}

// func (s vulnerabilityProvider) GetByDistro(d *distro.Distro, p pkg.Package) ([]vulnerability.Vulnerability, error) {
//	return s.FindVulnerabilities(
//		NewPackageNameCriteria(p.Name),
//		NewDistroCriteria(*d),
//	)
//}

// func (s vulnerabilityProvider) GetByLanguage(language syftPkg.Language, p pkg.Package) ([]vulnerability.Vulnerability, error) {
//	return s.FindVulnerabilities(
//		NewPackageNameCriteria(p.Name),
//		NewLanguageCriteria(language),
//	)
//}

func (s vulnerabilityProvider) VulnerabilityMetadata(ref vulnerability.Reference) (*vulnerability.Metadata, error) {
	vuln, ok := ref.Internal.(*VulnerabilityHandle)
	if !ok {
		return nil, fmt.Errorf("no vulnerability ID found")
	}
	return &vulnerability.Metadata{
		ID:          vuln.Name,
		DataSource:  vuln.Provider.ID,
		Namespace:   ref.Namespace,
		Severity:    toSeverityString(vuln),
		URLs:        toURLs(vuln),
		Description: vuln.BlobValue.Description,
		Cvss:        toCvss(vuln.BlobValue.Severities...),
	}, nil
}

// func (s vulnerabilityProvider) GetMetadata(id string, namespace string) (*vulnerability.Metadata, error) {
//	log.Warnf("GetMetadata(id,namespace) is deprecated and will likely give incorrect results when invoked against a v6 database")
//	vulns, err := s.reader.GetVulnerabilities(&VulnerabilitySpecifier{
//		Name: id,
//	}, &GetVulnerabilityOptions{
//		Preload: true,
//	})
//	if len(vulns) == 0 || err != nil {
//		return nil, err
//	}
//	vuln := &vulns[0]
//	return &vulnerability.Metadata{
//		ID:          vuln.Name,
//		DataSource:  vuln.Provider.ID,
//		Namespace:   namespace, // FIXME -- setting this to the caller provided namespace is probably wrong
//		Severity:    toSeverityString(vuln),
//		URLs:        toURLs(vuln),
//		Description: vuln.BlobValue.Description,
//		Cvss:        toCvss(vuln.BlobValue.Severities...),
//	}, nil
//}

func (s vulnerabilityProvider) Close() error {
	return s.reader.(io.Closer).Close()
}

// func (s vulnerabilityProvider) GetByCPE(c cpe.CPE) ([]vulnerability.Vulnerability, error) {
//	return s.FindVulnerabilities(NewCPECriteria(c))
//}

//nolint:funlen,gocognit
func (s vulnerabilityProvider) FindVulnerabilities(criteria ...vulnerability.Criteria) ([]vulnerability.Vulnerability, error) {
	var err error

	var out []vulnerability.Vulnerability
	for _, criteriaSet := range criteriaSetIterator(criteria) {
		var vulnSpec *VulnerabilitySpecifier
		var pkgSpec *PackageSpecifier
		var cpeSpec *cpe.Attributes
		var osSpec *OSSpecifier

		for i := 0; i < len(criteriaSet); i++ {
			applied := false
			requirePostFilter := false
			mergeApplied := func(err error) error {
				applied = true
				if err != nil {
					if err != errRequirePostFilter {
						return err
					}
					requirePostFilter = true
				}
				return nil
			}

			c := criteriaSet[i]
			if q, ok := c.(queryVulnerabilitySpecifier); ok {
				if vulnSpec == nil {
					vulnSpec = &VulnerabilitySpecifier{}
				}
				if err = mergeApplied(q.VulnerabilitySpecifier(vulnSpec)); err != nil {
					return nil, err
				}
			}
			if q, ok := c.(queryPackageSpecifier); ok {
				if pkgSpec == nil {
					pkgSpec = &PackageSpecifier{}
				}
				if err = mergeApplied(q.PackageSpecifier(pkgSpec)); err != nil {
					return nil, err
				}
			}
			if q, ok := c.(queryCPESpecifier); ok {
				if cpeSpec == nil {
					cpeSpec = &cpe.Attributes{}
				}
				if err = mergeApplied(q.CPESpecifier(cpeSpec)); err != nil {
					return nil, err
				}
				// cpeCriteria also implements queryPackageSpecifier, so doesn't need it here. Should we just do this instead?:
				// if pkgSpec == nil {
				//	pkgSpec = &PackageSpecifier{}
				// }
				// pkgSpec.CPE = cpeSpec
			}
			if q, ok := c.(queryOSSpecifier); ok {
				if osSpec == nil {
					osSpec = &OSSpecifier{}
				}
				if err = mergeApplied(q.OSSpecifier(osSpec)); err != nil {
					return nil, err
				}
			}

			// remove fully applied criteria from later checks
			if applied && !requirePostFilter {
				criteriaSet = append(criteriaSet[0:i], criteriaSet[i+1:]...)
				i--
			}
		}

		var vulnSpecs VulnerabilitySpecifiers
		if vulnSpec != nil {
			vulnSpecs = append(vulnSpecs, *vulnSpec)
		}

		var osSpecs OSSpecifiers
		if osSpec != nil {
			osSpecs = append(osSpecs, osSpec)
		}

		var affectedPackages []AffectedPackageHandle
		var affectedCPEs []AffectedCPEHandle

		if pkgSpec != nil || vulnSpec != nil {
			affectedPackages, err = s.reader.GetAffectedPackages(pkgSpec, &GetAffectedPackageOptions{
				OSs:             osSpecs,
				Vulnerabilities: vulnSpecs,
			})
			if err != nil {
				return nil, err
			}
		}

		if cpeSpec != nil {
			affectedCPEs, err = s.reader.GetAffectedCPEs(cpeSpec, &GetAffectedCPEOptions{
				PreloadCPE:      true,
				Vulnerabilities: vulnSpecs,
			})
			if err != nil {
				return nil, err
			}
		}

		// need blob values filled out for affected version constraints/ranges
		if err = fillAffectedPackageHandles(s.db, ptrs(affectedPackages)); err != nil {
			return nil, err
		}
		affectedPackages = filterAffectedVersions(affectedPackages, criteriaSet)

		// after filtering, read vulnerability data
		if err = fillAffectedPackageHandles(s.db, ptrs(affectedPackages)); err != nil {
			return nil, err
		}

		// fill complete vulnerabilities for this set
		vulns, err := s.toVulns(affectedPackages, affectedCPEs)
		if err != nil {
			return nil, err
		}

		// filter vulnerabilities by any remaining criteria such as ByQualifiedPackages
		vulns, err = s.filterVulnerabilities(vulns, criteriaSet...)
		if err != nil {
			return nil, err
		}

		out = append(out, vulns...)
	}

	return out, nil
}

// criteriaSetIterator processes all OR conditions into distinct sets of flattened criteria
func criteriaSetIterator(criteria []vulnerability.Criteria) iter.Seq2[int, []vulnerability.Criteria] {
	if len(criteria) == 0 {
		return func(_ func(int, []vulnerability.Criteria) bool) {
		}
	}
	return func(yield func(int, []vulnerability.Criteria) bool) {
		idx := 0
		fn := func(criteria []vulnerability.Criteria) bool {
			out := yield(idx, criteria)
			idx++
			return out
		}
		_ = processRemaining(nil, criteria, fn)
	}
}

func processRemaining(row, criteria []vulnerability.Criteria, yield func([]vulnerability.Criteria) bool) bool {
	if len(criteria) == 0 {
		return yield(row)
	}
	return processRemainingItem(row, criteria[1:], criteria[0], yield)
}

func processRemainingItem(row, criteria []vulnerability.Criteria, item vulnerability.Criteria, yield func([]vulnerability.Criteria) bool) bool {
	switch item := item.(type) {
	case requiredCriteriaContainer:
		// we replace this criteria object with its constituent parts
		return processRemaining(row, append(item.RequiredCriteria(), criteria...), yield)
	case optionalCriteriaContainer:
		for _, option := range item.OptionalCriteria() {
			if !processRemainingItem(row, criteria, option, yield) {
				return false
			}
		}
	default:
		return processRemaining(append(row, item), criteria, yield)
	}
	return true // continue
}

func filterAffectedVersions(packages []AffectedPackageHandle, criteria []vulnerability.Criteria) []AffectedPackageHandle {
	var constraintMatcher versionConstraintMatcher
	for _, c := range criteria {
		if nextMatcher, ok := c.(versionConstraintMatcher); ok {
			if constraintMatcher == nil {
				constraintMatcher = nextMatcher
			} else {
				constraintMatcher = &multiConstraintMatcher{
					a: constraintMatcher,
					b: nextMatcher,
				}
			}
		}
	}
	// no constraint matcher, just return all packages
	if constraintMatcher == nil {
		return packages
	}
nextPackage:
	for i := 0; i < len(packages); i++ {
		b := packages[i].BlobValue
		for _, r := range b.Ranges {
			v := r.Version
			format := version.ParseFormat(v.Type)
			constraint, err := version.GetConstraint(v.Constraint, format)
			if err != nil {
				log.WithFields("error", err, "constraint", v.Constraint, "format", v.Type).Debug("unable to parse constraint")
				continue
			}
			matches, err := constraintMatcher.MatchesConstraint(constraint)
			if err != nil {
				log.WithFields("error", err, "constraint", v.Constraint, "format", v.Type).Debug("match constraint error")
			}
			if matches {
				continue nextPackage
			}
		}
		// if we haven't matched a constraint, remove the package
		packages = append(packages[:i], packages[i+1:]...)
		i--
	}
	return packages
}

func toSeverityString(vuln *VulnerabilityHandle) string {
	return strcase.ToCamel(getSeverity(vuln).String())
}

func getSeverity(vuln *VulnerabilityHandle) vulnerability.Severity {
	if vuln.BlobValue == nil {
		return vulnerability.UnknownSeverity
	}
	if len(vuln.BlobValue.Severities) > 0 {
		return extractSeverity(vuln.BlobValue.Severities[0].Value)
	}
	return vulnerability.UnknownSeverity
}

func extractSeverity(severity any) vulnerability.Severity {
	switch sev := severity.(type) {
	case CVSSSeverity:
		return normalizedScoreToSeverityValue(sev.Score / 10.)
	default:
		return vulnerability.UnknownSeverity
	}
}

func normalizedScoreToSeverityValue(score float64) vulnerability.Severity {
	if score > .9 {
		return vulnerability.CriticalSeverity
	}
	if score > .7 {
		return vulnerability.HighSeverity
	}
	if score > .4 {
		return vulnerability.MediumSeverity
	}
	if score > .2 {
		return vulnerability.LowSeverity
	}
	if score >= .0 {
		return vulnerability.NegligibleSeverity
	}
	return vulnerability.UnknownSeverity
}

func toURLs(vuln *VulnerabilityHandle) []string {
	var out []string
	for _, v := range vuln.BlobValue.References {
		out = append(out, v.URL)
	}
	return out
}

func (s vulnerabilityProvider) toVulns(packageHandles []AffectedPackageHandle, cpeHandles []AffectedCPEHandle) ([]vulnerability.Vulnerability, error) {
	var out []vulnerability.Vulnerability

	// ensure all data we need is filled out
	packageHandlePtrs := ptrs(packageHandles)
	if err := errors.Join(
		fillAffectedPackageHandles(s.db, packageHandlePtrs),
		s.fillVulnerabilityHandles(affectedPackageVulnerabilityHandles(packageHandlePtrs)),
	); err != nil {
		return nil, err
	}

	cpeHandlePtrs := ptrs(cpeHandles)
	if err := errors.Join(
		s.fillAffectedCPEHandles(cpeHandlePtrs),
		s.fillVulnerabilityHandles(affectedCPEVulnerabilityHandles(cpeHandlePtrs)),
	); err != nil {
		return nil, err
	}

	for _, packageHandle := range packageHandles {
		if packageHandle.BlobValue == nil {
			log.Debugf("unable to find blobValue for %+v", packageHandle)
			continue
		}
		for _, rng := range packageHandle.BlobValue.Ranges {
			v, err := newVulnerabilityFromAffectedPackageHandle(s.reader, packageHandle, rng)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			out = append(out, *v)
		}
	}

	if err := s.fillVulnerabilityHandles(affectedCPEVulnerabilityHandles(ptrs(cpeHandles))); err != nil {
		return out, err
	}

	for _, c := range cpeHandles {
		if c.BlobValue == nil {
			log.Debugf("unable to find blobValue for %+v", c)
			continue
		}
		for _, rng := range c.BlobValue.Ranges {
			v, err := newVulnerabilityFromAffectedCPEHandle(s.reader, c, rng)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			out = append(out, *v)
		}
	}

	return out, nil
}

func (s vulnerabilityProvider) fillProviders(handles []*VulnerabilityHandle) error {
	if len(s.providers) == 0 {
		var providers []*Provider
		tx := s.db.Find(&providers)
		if tx.Error != nil {
			return tx.Error
		}
		for _, p := range providers {
			s.providers[p.ID] = p
		}
	}

	for _, h := range handles {
		h.Provider = s.providers[h.ProviderID]
	}

	return nil
}

func (s vulnerabilityProvider) filterVulnerabilities(vulns []vulnerability.Vulnerability, criteria ...vulnerability.Criteria) ([]vulnerability.Vulnerability, error) {
	isMatch := func(v vulnerability.Vulnerability) (bool, error) {
		for _, c := range criteria {
			if _, ok := c.(versionConstraintMatcher); ok {
				continue // already run
			}
			matches, err := c.MatchesVulnerability(v)
			if !matches || err != nil {
				return false, err
			}
		}
		return true, nil
	}
	for i := 0; i < len(vulns); i++ {
		matches, err := isMatch(vulns[i])
		if err != nil {
			return nil, err
		}
		if !matches {
			vulns = append(vulns[0:i], vulns[i+1:]...)
			i--
		}
	}
	return vulns, nil
}

var _ interface {
	vulnerability.Provider
} = (*vulnerabilityProvider)(nil)
