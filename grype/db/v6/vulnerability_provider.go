package v6

import (
	"errors"
	"io"
	"strconv"

	"github.com/iancoleman/strcase"
	"gorm.io/gorm"

	"github.com/anchore/grype/grype/db/internal/gormadapter"
	"github.com/anchore/grype/grype/distro"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/grype/internal/log"
	"github.com/anchore/syft/syft/cpe"
	syftPkg "github.com/anchore/syft/syft/pkg"
)

type VulnerabilityCriteria struct {
	p        pkg.Package
	cpe      *cpe.CPE
	language *syftPkg.Language
	distro   *distro.Distro
	id       string
}

type VulnerabilityProvider interface {
	FindVulnerabilities(criteria ...VulnerabilityCriteria) ([]vulnerability.Vulnerability, error)
}

func NewVulnerabilityProvider(rdr Reader) VulnerabilityProvider {
	return &vulnerabilityProvider{
		db:     getDB(rdr),
		reader: rdr,
	}
}

func getDB(rdr Reader) *gorm.DB {
	return rdr.(gormadapter.GetDB).GetDB()
}

type vulnerabilityProvider struct {
	db     *gorm.DB
	reader Reader
}

func (s vulnerabilityProvider) Get(id, _ string) ([]vulnerability.Vulnerability, error) {
	return s.FindVulnerabilities(NameCriteria(id))
}

func (s vulnerabilityProvider) GetByDistro(d *distro.Distro, p pkg.Package) ([]vulnerability.Vulnerability, error) {
	return s.FindVulnerabilities(DistroCriteria(p, d))
}

func (s vulnerabilityProvider) GetByLanguage(language syftPkg.Language, p pkg.Package) ([]vulnerability.Vulnerability, error) {
	p.Language = language
	return s.FindVulnerabilities(LanguageCriteria(p))
}

func (s vulnerabilityProvider) GetMetadata(id string, namespace string) (*vulnerability.Metadata, error) {
	vulns, err := s.reader.GetVulnerabilities(&VulnerabilitySpecifier{
		Name: id,
	}, &GetVulnerabilityOptions{
		Preload: true,
	})
	if len(vulns) == 0 || err != nil {
		return nil, err
	}
	vuln := vulns[0]
	return &vulnerability.Metadata{
		ID:          vuln.Name,
		DataSource:  vuln.Provider.ID,
		Namespace:   namespace, // FIXME -- setting this to the caller provided namespace is probably wrong
		Severity:    toSeverityString(vuln),
		URLs:        toURLs(vuln),
		Description: vuln.BlobValue.Description,
		Cvss:        NewCvss(vuln.BlobValue.Severities...),
	}, nil
}

func (s vulnerabilityProvider) Close() error {
	return s.reader.(io.Closer).Close()
}

func (s vulnerabilityProvider) GetRules(_ string) ([]match.IgnoreRule, error) {
	return nil, nil
}

func (s vulnerabilityProvider) GetByCPE(c cpe.CPE) ([]vulnerability.Vulnerability, error) {
	return s.FindVulnerabilities(CPECriteria(pkg.Package{Name: c.Attributes.Product}, c))
}

//nolint:funlen,gocognit
func (s vulnerabilityProvider) FindVulnerabilities(crit ...VulnerabilityCriteria) ([]vulnerability.Vulnerability, error) {
	var errs error
	var out []vulnerability.Vulnerability
	for _, c := range crit {
		if c.id != "" {
			handles, err := s.reader.GetAffectedPackages(&PackageSpecifier{}, &GetAffectedPackageOptions{
				Vulnerability: &VulnerabilitySpecifier{
					Name: c.id,
				},
			})
			if err != nil {
				return nil, err
			}

			return s.toVulns(c.p.Name, handles, nil)
		}

		var affectedPackages []AffectedPackageHandle
		var affectedCPEs []AffectedCPEHandle

		// when searching by CPEs, we need to look for
		if c.cpe != nil {
			cp := c.cpe
			pkgs, err := s.reader.GetAffectedPackages(&PackageSpecifier{
				CPE: &cp.Attributes,
			}, &GetAffectedPackageOptions{
				PreloadVulnerability: false,
			})
			if err != nil {
				return nil, err
			}

			affectedPackages = append(affectedPackages, pkgs...)

			cpes, err := s.reader.GetAffectedCPEs(&cp.Attributes, &GetAffectedCPEOptions{
				PreloadCPE:           true,
				PreloadVulnerability: false,
			})
			if err != nil {
				return nil, err
			}

			affectedCPEs = append(affectedCPEs, cpes...)
		}

		if c.language != nil && *c.language != "" {
			pkgs, err := s.reader.GetAffectedPackages(&PackageSpecifier{
				Name: c.p.Name,
				Type: string(*c.language),
			}, &GetAffectedPackageOptions{
				PreloadOS:            false,
				PreloadPackage:       false,
				PreloadPackageCPEs:   false,
				PreloadVulnerability: false,
				PreloadBlob:          false,
				Distro:               nil,
				Vulnerability:        nil,
			})
			if err != nil {
				return nil, err
			}

			affectedPackages = append(affectedPackages, pkgs...)
		}

		if c.distro != nil {
			d := c.distro
			minorVersion := ""
			if d.Version != nil {
				segs := d.Version.Segments()
				if len(segs) > 1 {
					minorVersion = strconv.Itoa(segs[1])
				}
			}
			pkgs, err := s.reader.GetAffectedPackages(&PackageSpecifier{
				Name: c.p.Name,
			}, &GetAffectedPackageOptions{
				Distro: &DistroSpecifier{
					Name:          d.Name(),
					MajorVersion:  d.MajorVersion(),
					MinorVersion:  minorVersion,
					LabelVersion:  "",
					Codename:      "",
					AllowMultiple: true, // TODO it's unclear when/why I choose this option
				},
			})
			if err != nil {
				return nil, err
			}

			affectedPackages = append(affectedPackages, pkgs...)
		}

		// after filtering, read vulnerability data
		if err := fillAffectedPackageHandles(s.db, affectedPackages); err != nil {
			return nil, err
		}

		vulns, err := s.toVulns(c.p.Name, affectedPackages, affectedCPEs)
		if err != nil {
			errs = errors.Join(errs, err)
		}
		out = append(out, vulns...)
	}

	return out, errs
}

func toSeverityString(vuln VulnerabilityHandle) string {
	return strcase.ToCamel(getSeverity(vuln).String())
}

func getSeverity(vuln VulnerabilityHandle) vulnerability.Severity {
	if vuln.BlobValue == nil {
		return vulnerability.UnknownSeverity
	}
	if len(vuln.BlobValue.Severities) > 0 {
		return extractSeverity(vuln.BlobValue.Severities[0].Value)
	}
	return vulnerability.UnknownSeverity
}

func extractSeverity(severity any) vulnerability.Severity {
	switch sev := severity.(type) {
	case CVSSSeverity:
		return normalizedScoreToSeverityValue(sev.Score / 10.)
	default:
		return vulnerability.UnknownSeverity
	}
}

func normalizedScoreToSeverityValue(score float64) vulnerability.Severity {
	if score > .9 {
		return vulnerability.CriticalSeverity
	}
	if score > .7 {
		return vulnerability.HighSeverity
	}
	if score > .4 {
		return vulnerability.MediumSeverity
	}
	if score > .2 {
		return vulnerability.LowSeverity
	}
	if score >= .0 {
		return vulnerability.NegligibleSeverity
	}
	return vulnerability.UnknownSeverity
}

func toURLs(vuln VulnerabilityHandle) []string {
	var out []string
	for _, v := range vuln.BlobValue.References {
		out = append(out, v.URL)
	}
	return out
}

func (s vulnerabilityProvider) toVulns(packageName string, packageHandles []AffectedPackageHandle, cpeHandles []AffectedCPEHandle) ([]vulnerability.Vulnerability, error) {
	var out []vulnerability.Vulnerability

	// ensure all data we need is filled out
	if err := errors.Join(
		fillAffectedPackageHandles(s.db, packageHandles),
		fillAffectedCPEHandles(s.db, cpeHandles),
	); err != nil {
		return nil, err
	}

	for _, packageHandle := range packageHandles {
		if packageHandle.BlobValue == nil {
			log.Debugf("unable to find blobValue for %+v", packageHandle)
			continue
		}
		for _, rng := range packageHandle.BlobValue.Ranges {
			v, err := NewVulnerabilityFromAffectedPackageHandle(s.reader, packageHandle, rng)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			out = append(out, *v)
		}
	}

	for _, c := range cpeHandles {
		if c.BlobValue == nil {
			log.Debugf("unable to find blobValue for %+v", c)
			continue
		}
		for _, rng := range c.BlobValue.Ranges {
			v, err := NewVulnerabilityFromAffectedCPEHandle(s.reader, packageName, c, rng)
			if err != nil {
				return nil, err
			}
			if v == nil {
				continue
			}
			out = append(out, *v)
		}
	}

	return out, nil
}

var _ interface {
	VulnerabilityProvider
	vulnerability.Provider
	vulnerability.MetadataProvider
	match.ExclusionProvider
	io.Closer
} = (*vulnerabilityProvider)(nil)
