package v6

import (
	"encoding/json"
	"fmt"

	"gorm.io/gorm"

	"github.com/anchore/grype/internal/log"
)

type VulnerabilityStoreWriter interface {
	AddVulnerabilities(vulns ...*VulnerabilityHandle) error
}

type VulnerabilityStoreReader interface {
	GetVulnerability(id ID, config *GetVulnerabilityOptions) (*VulnerabilityHandle, error)
	GetVulnerabilitiesByName(vulnID string, config *GetVulnerabilityOptions) ([]VulnerabilityHandle, error)
}

type GetVulnerabilityOptions struct {
	Preload bool
}

func DefaultGetVulnerabilityOptions() *GetVulnerabilityOptions {
	return &GetVulnerabilityOptions{
		Preload: false,
	}
}

type vulnerabilityStore struct {
	db        *gorm.DB
	blobStore *blobStore
}

func newVulnerabilityStore(db *gorm.DB, bs *blobStore) *vulnerabilityStore {
	return &vulnerabilityStore{
		db:        db,
		blobStore: bs,
	}
}

func (s *vulnerabilityStore) GetVulnerability(id ID, config *GetVulnerabilityOptions) (*VulnerabilityHandle, error) {
	if config == nil {
		config = DefaultGetVulnerabilityOptions()
	}
	log.WithFields("id", id, "preload", config.Preload).Trace("fetching Vulnerability record")

	if id == 0 {
		return nil, fmt.Errorf("id must be > 0")
	}

	var model VulnerabilityHandle

	result := s.db.Where("id = ?", id).First(&model)

	if result.Error != nil {
		return nil, fmt.Errorf("unable to fetch vulnerability record: %w", result.Error)
	}

	var err error
	if config.Preload {
		err = s.attachBlob(&model)
	}

	return &model, err
}

func (s *vulnerabilityStore) GetVulnerabilitiesByName(name string, config *GetVulnerabilityOptions) ([]VulnerabilityHandle, error) {
	if config == nil {
		config = DefaultGetVulnerabilityOptions()
	}
	log.WithFields("name", name, "preload", config.Preload).Trace("fetching Vulnerability record")

	var allModels []VulnerabilityHandle

	err := s.db.Where("name = ?", name).Find(&allModels).Error

	if err != nil {
		return nil, fmt.Errorf("unable to fetch vulnerability record: %w", err)
	}

	if config.Preload {
		for i := range allModels {
			err := s.attachBlob(&allModels[i])
			if err != nil {
				return nil, fmt.Errorf("unable to attach blob %#v: %w", allModels[i], err)
			}
		}
	}

	return allModels, nil
}

func (s *vulnerabilityStore) attachBlob(vh *VulnerabilityHandle) error {
	var blobValue *VulnerabilityBlob

	rawValue, err := s.blobStore.getBlobValue(vh.BlobID)
	if err != nil {
		return fmt.Errorf("unable to fetch vulnerability blob value: %w", err)
	}

	err = json.Unmarshal([]byte(rawValue), &blobValue)
	if err != nil {
		return fmt.Errorf("unable to unmarshal vulnerability blob value: %w", err)
	}

	vh.BlobValue = blobValue

	return nil
}

func (s *vulnerabilityStore) AddVulnerabilities(vulnerabilities ...*VulnerabilityHandle) error {
	for _, v := range vulnerabilities {
		// this adds the blob value to the DB and sets the ID on the vulnerability handle
		if err := s.blobStore.addBlobable(v); err != nil {
			return fmt.Errorf("unable to add affected blob: %w", err)
		}

		// write the vulnerability handle to the DB
		if err := s.db.Create(v).Error; err != nil {
			return err
		}
	}
	return nil
}
