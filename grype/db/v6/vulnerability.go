package v6

import (
	"fmt"

	"github.com/anchore/grype/grype/pkg/qualifier"
	"github.com/anchore/grype/grype/pkg/qualifier/platformcpe"
	"github.com/anchore/grype/grype/pkg/qualifier/rpmmodularity"
	"github.com/anchore/grype/grype/version"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft/cpe"
)

func newVulnerabilityFromAffectedPackageHandle(rdr Reader, affected AffectedPackageHandle, affectedRange AffectedRange) (*vulnerability.Vulnerability, error) {
	packageName := ""
	if affected.Package != nil {
		packageName = affected.Package.Name
	}

	vuln := affected.Vulnerability
	if vuln == nil || vuln.BlobValue == nil {
		var err error
		vuln, err = getVulnerability(rdr, affected.VulnerabilityID)
		if err != nil {
			return nil, err
		}
	}

	return newVulnerabilityFromParts(packageName, vuln, affected.BlobValue, affectedRange)
}

func newVulnerabilityFromAffectedCPEHandle(rdr Reader, affected AffectedCPEHandle, affectedRange AffectedRange) (*vulnerability.Vulnerability, error) {
	vuln := affected.Vulnerability
	if vuln == nil || vuln.BlobValue == nil {
		var err error
		vuln, err = getVulnerability(rdr, affected.VulnerabilityID)
		if err != nil {
			return nil, err
		}
	}
	return newVulnerabilityFromParts(affected.CPE.Product, vuln, affected.BlobValue, affectedRange)
}

func getVulnerability(rdr Reader, id ID) (*VulnerabilityHandle, error) {
	var err error
	vulns, err := rdr.GetVulnerabilities(&VulnerabilitySpecifier{ID: id}, &GetVulnerabilityOptions{
		Preload: true,
	})
	if err != nil {
		return nil, err
	}
	if len(vulns) == 0 {
		return nil, fmt.Errorf("no vulnerabilities found for package %v", id)
	}
	return &vulns[0], nil
}

func newVulnerabilityFromParts(packageName string, vuln *VulnerabilityHandle, affected *AffectedPackageBlob, affectedRange AffectedRange) (*vulnerability.Vulnerability, error) {
	if vuln.BlobValue == nil {
		return nil, fmt.Errorf("vuln has no blob value: %+v", vuln) // FIXME we could just query the db
	}

	var advisories []vulnerability.Advisory // TODO check with Weston where to find this
	for _, ref := range vuln.BlobValue.References {
		advisories = append(advisories, vulnerability.Advisory{
			Link: ref.URL,
		})
	}

	var relatedVulnerabilities []vulnerability.Reference
	for _, alias := range vuln.BlobValue.Aliases {
		relatedVulnerabilities = append(relatedVulnerabilities, vulnerability.Reference{
			ID: alias,
		})
	}
	var packageQualifiers []qualifier.Qualifier
	if affected != nil {
		for _, cve := range affected.CVEs {
			relatedVulnerabilities = append(relatedVulnerabilities, vulnerability.Reference{
				ID: cve,
			})
		}
		packageQualifiers = toPackageQualifiers(affected.Qualifiers)
	}
	versionFormat := version.ParseFormat(affectedRange.Version.Type)
	constraint, err := version.GetConstraint(affectedRange.Version.Constraint, versionFormat)
	if err != nil {
		return nil, fmt.Errorf("failed to parse constraint='%s' format='%s': %w", affectedRange.Version.Constraint, versionFormat, err)
	}

	return &vulnerability.Vulnerability{
		Reference: vulnerability.Reference{
			ID:       vuln.Name,
			Internal: vuln, // just hold a reference to the vulnHandle for later use
		},
		PackageName:            packageName,
		PackageQualifiers:      packageQualifiers,
		Constraint:             constraint,
		CPEs:                   toCPEs(vuln.BlobValue),
		RelatedVulnerabilities: relatedVulnerabilities,
		Fix:                    toFix(affectedRange.Fix),
		Advisories:             advisories,
	}, nil
}

func toPackageQualifiers(qualifiers *AffectedPackageQualifiers) []qualifier.Qualifier {
	if qualifiers == nil {
		return nil
	}
	var out []qualifier.Qualifier
	for _, c := range qualifiers.PlatformCPEs {
		out = append(out, platformcpe.New(c))
	}
	if qualifiers.RpmModularity == "" {
		out = append(out, rpmmodularity.New(qualifiers.RpmModularity))
	}
	return out
}

func toFix(fix *Fix) vulnerability.Fix {
	if fix == nil || fix.Version == "" {
		return vulnerability.Fix{}
	}
	return vulnerability.Fix{
		Versions: []string{fix.Version},
		State:    vulnerability.FixState(fix.State),
	}
}

func toCPEs(vuln *VulnerabilityBlob) []cpe.CPE {
	var out []cpe.CPE
	for _, id := range append(vuln.Aliases, vuln.ID) {
		c, err := cpe.New(id, cpe.DeclaredSource)
		if err != nil {
			out = append(out, c)
		}
	}
	return out
}
