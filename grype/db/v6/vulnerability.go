package v6

import (
	"fmt"
	"strings"

	"github.com/anchore/grype/grype/pkg/qualifier"
	"github.com/anchore/grype/grype/pkg/qualifier/platformcpe"
	"github.com/anchore/grype/grype/pkg/qualifier/rpmmodularity"
	"github.com/anchore/grype/grype/version"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft/cpe"
)

func newVulnerabilityFromAffectedPackageHandle(rdr Reader, affected AffectedPackageHandle, affectedRange AffectedRange) (*vulnerability.Vulnerability, error) {
	packageName := ""
	if affected.Package != nil {
		packageName = affected.Package.Name
	}

	vuln := affected.Vulnerability
	if vuln == nil || vuln.BlobValue == nil {
		var err error
		vuln, err = getVulnerability(rdr, affected.VulnerabilityID)
		if err != nil {
			return nil, err
		}
	}

	return newVulnerabilityFromParts(packageName, vuln, affected.BlobValue, affectedRange, &affected, nil)
}

func newVulnerabilityFromAffectedCPEHandle(rdr Reader, affected AffectedCPEHandle, affectedRange AffectedRange) (*vulnerability.Vulnerability, error) {
	vuln := affected.Vulnerability
	if vuln == nil || vuln.BlobValue == nil {
		var err error
		vuln, err = getVulnerability(rdr, affected.VulnerabilityID)
		if err != nil {
			return nil, err
		}
	}
	return newVulnerabilityFromParts(affected.CPE.Product, vuln, affected.BlobValue, affectedRange, nil, &affected)
}

func getVulnerability(rdr Reader, id ID) (*VulnerabilityHandle, error) {
	var err error
	vulns, err := rdr.GetVulnerabilities(&VulnerabilitySpecifier{ID: id}, &GetVulnerabilityOptions{
		Preload: true,
	})
	if err != nil {
		return nil, err
	}
	if len(vulns) == 0 {
		return nil, fmt.Errorf("no vulnerabilities found for package %v", id)
	}
	return &vulns[0], nil
}

func newVulnerabilityFromParts(packageName string, vuln *VulnerabilityHandle, affected *AffectedPackageBlob, affectedRange AffectedRange, affectedPackageHandle *AffectedPackageHandle, affectedCpeHandle *AffectedCPEHandle) (*vulnerability.Vulnerability, error) {
	if vuln.BlobValue == nil {
		return nil, fmt.Errorf("vuln has no blob value: %+v", vuln) // FIXME we could just query the db
	}

	v5namespace := MimicV5Namespace(vuln, affectedPackageHandle)

	var advisories []vulnerability.Advisory // TODO check with Weston where to find this
	for _, ref := range vuln.BlobValue.References {
		if ref.URL == "" {
			continue
		}
		advisories = append(advisories, vulnerability.Advisory{
			Link: ref.URL,
		})
	}

	var relatedVulnerabilities []vulnerability.Reference
	for _, alias := range vuln.BlobValue.Aliases {
		relatedVulnerabilities = append(relatedVulnerabilities, vulnerability.Reference{
			ID:        alias,
			Namespace: v5namespace,
		})
	}
	var packageQualifiers []qualifier.Qualifier
	if affected != nil {
		for _, cve := range affected.CVEs {
			relatedVulnerabilities = append(relatedVulnerabilities, vulnerability.Reference{
				ID:        cve,
				Namespace: v5namespace,
			})
		}
		packageQualifiers = toPackageQualifiers(affected.Qualifiers)
	}
	versionFormat := version.ParseFormat(affectedRange.Version.Type)
	constraint, err := version.GetConstraint(affectedRange.Version.Constraint, versionFormat)
	if err != nil {
		return nil, fmt.Errorf("failed to parse constraint='%s' format='%s': %w", affectedRange.Version.Constraint, versionFormat, err)
	}

	return &vulnerability.Vulnerability{
		Reference: vulnerability.Reference{
			ID:        vuln.Name,
			Namespace: v5namespace,
			Internal:  vuln, // just hold a reference to the vulnHandle for later use
		},
		PackageName:            packageName,
		PackageQualifiers:      packageQualifiers,
		Constraint:             constraint,
		CPEs:                   toCPEs(affectedPackageHandle, affectedCpeHandle),
		RelatedVulnerabilities: relatedVulnerabilities,
		Fix:                    toFix(affectedRange.Fix),
		Advisories:             advisories,
	}, nil
}

// MimicV5Namespace returns the namespace for a given affected package based on what schema v5 did.
//
//nolint:funlen
func MimicV5Namespace(vuln *VulnerabilityHandle, affected *AffectedPackageHandle) string {
	if affected == nil { // for CPE matches
		return "nvd:cpe"
	}
	switch vuln.Provider.ID {
	case "nvd":
		return "nvd:cpe"
	case "github":
		language := affected.Package.Ecosystem
		// normalize from purl type, github ecosystem types, and vunnel mappings
		switch strings.ToLower(language) {
		case "golang", "go-module":
			language = "go"
		case "composer", "php-composer":
			language = "php"
		case "cargo", "rust-crate":
			language = "rust"
		case "dart-pub", "pub":
			language = "dart"
		case "nuget":
			language = "dotnet"
		case "maven":
			language = "java"
		case "swifturl":
			language = "swift"
		case "npm", "node":
			language = "javascript"
		case "pypi", "pip":
			language = "python"
		case "rubygems", "gem":
			language = "ruby"
		}
		return fmt.Sprintf("github:language:%s", language)
	}
	if affected.OperatingSystem != nil {
		// distro family fixes
		family := affected.OperatingSystem.Name
		ver := affected.OperatingSystem.Version()
		switch affected.OperatingSystem.Name {
		case "amazon":
			family = "amazonlinux"
		case "mariner":
			switch ver {
			case "1.0", "2.0":
				family = "mariner"
			default:
				family = "azurelinux"
			}
		case "oracle":
			family = "oraclelinux"
		}

		// provider fixes
		pr := vuln.Provider.ID
		if pr == "rhel" {
			pr = "redhat"
		}

		// version fixes
		switch vuln.Provider.ID {
		case "rhel", "oracle":
			// ensure we only keep the major version
			ver = strings.Split(ver, ".")[0]
		}

		return fmt.Sprintf("%s:distro:%s:%s", pr, family, ver)
	}
	return vuln.Provider.ID
}

func toPackageQualifiers(qualifiers *AffectedPackageQualifiers) []qualifier.Qualifier {
	if qualifiers == nil {
		return nil
	}
	var out []qualifier.Qualifier
	for _, c := range qualifiers.PlatformCPEs {
		out = append(out, platformcpe.New(c))
	}
	if qualifiers.RpmModularity == "" {
		out = append(out, rpmmodularity.New(qualifiers.RpmModularity))
	}
	return out
}

func toFix(fix *Fix) vulnerability.Fix {
	if fix == nil || fix.Version == "" {
		return vulnerability.Fix{}
	}
	return vulnerability.Fix{
		Versions: []string{fix.Version},
		State:    vulnerability.FixState(fix.State),
	}
}

func toCPEs(affectedPackageHandle *AffectedPackageHandle, affectedCPEHandle *AffectedCPEHandle) []cpe.CPE {
	var out []cpe.CPE
	var cpes []Cpe
	if affectedPackageHandle != nil {
		cpes = affectedPackageHandle.Package.CPEs
	}
	if affectedCPEHandle != nil && affectedCPEHandle.CPE != nil {
		cpes = append(cpes, *affectedCPEHandle.CPE)
	}
	for _, c := range cpes {
		out = append(out, cpe.CPE{
			Attributes: cpe.Attributes{
				Part:      c.Part,
				Vendor:    c.Vendor,
				Product:   c.Product,
				Version:   cpe.Any,
				Update:    cpe.Any,
				Edition:   c.Edition,
				SWEdition: c.SoftwareEdition,
				TargetSW:  c.TargetSoftware,
				TargetHW:  c.TargetHardware,
				Other:     c.Other,
				Language:  c.Language,
			},
			Source: "",
		})
	}
	return out
}
