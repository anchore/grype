package v6

import (
	"fmt"
	"time"

	"gorm.io/gorm"

	"github.com/anchore/go-logger"
	"github.com/anchore/grype/internal/log"
	"github.com/anchore/grype/internal/schemaver"
)

type VulnerabilityDecoratorStoreWriter interface {
	AddKnownExploitedVulnerabilities(kevs ...*KnownExploitedVulnerabilityHandle) error
}

type VulnerabilityDecoratorStoreReader interface {
	GetKnownExploitedVulnerabilities(cve string) ([]KnownExploitedVulnerabilityHandle, error)
}

type vulnerabilityDecoratorStore struct {
	db         *gorm.DB
	blobStore  *blobStore
	kevEnabled bool
}

func newVulnerabilityDecoratorStore(db *gorm.DB, bs *blobStore, dbVersion schemaver.SchemaVer) *vulnerabilityDecoratorStore {
	minSupportedKEVClientVersion := schemaver.New(6, 0, 1)
	return &vulnerabilityDecoratorStore{
		db:         db,
		blobStore:  bs,
		kevEnabled: dbVersion.GreaterOrEqualTo(minSupportedKEVClientVersion),
	}
}

func (s *vulnerabilityDecoratorStore) AddKnownExploitedVulnerabilities(kevs ...*KnownExploitedVulnerabilityHandle) error {
	if !s.kevEnabled {
		// when populating a new DB we should never run into capability issues
		return ErrDBCapabilityNotSupported
	}

	for i := range kevs {
		k := kevs[i]
		// this adds the blob value to the DB and sets the ID on the kev handle
		if err := s.blobStore.addBlobable(k); err != nil {
			return fmt.Errorf("unable to add KEV blob: %w", err)
		}

		if err := s.db.Create(k).Error; err != nil {
			return fmt.Errorf("unable to create known exploited vulnerability: %w", err)
		}
	}
	return nil
}

func (s *vulnerabilityDecoratorStore) GetKnownExploitedVulnerabilities(cve string) ([]KnownExploitedVulnerabilityHandle, error) {
	if !s.kevEnabled {
		// capability incompatibilities should gracefully degrade, returning no data or errors
		return nil, nil
	}

	fields := logger.Fields{
		"cve": cve,
	}
	start := time.Now()
	var count int
	defer func() {
		fields["duration"] = time.Since(start)
		fields["records"] = count
		log.WithFields(fields).Trace("fetched KEV records")
	}()

	var models []KnownExploitedVulnerabilityHandle
	var results []*KnownExploitedVulnerabilityHandle

	if err := s.db.Where("cve = ?", cve).FindInBatches(&results, batchSize, func(_ *gorm.DB, _ int) error {
		var blobs []blobable
		for _, r := range results {
			blobs = append(blobs, r)
		}
		if err := s.blobStore.attachBlobValue(blobs...); err != nil {
			return fmt.Errorf("unable to attach KEV blobs: %w", err)
		}

		for _, r := range results {
			models = append(models, *r)
		}

		count += len(results)

		return nil
	}).Error; err != nil {
		return models, fmt.Errorf("unable to fetch KEV records: %w", err)
	}

	return models, nil
}
