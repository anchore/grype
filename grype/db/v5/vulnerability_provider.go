package v5

import (
	"fmt"

	"github.com/facebookincubator/nvdtools/wfn"

	cpeUtil "github.com/anchore/grype/grype/cpe"
	"github.com/anchore/grype/grype/db/v5/namespace"
	"github.com/anchore/grype/grype/distro"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/grype/internal/log"
	"github.com/anchore/syft/syft/cpe"
	syftPkg "github.com/anchore/syft/syft/pkg"
)

type vulnerabilityProvider struct {
	namespaceIndex   *namespace.Index
	metadataProvider VulnerabilityMetadataProvider
	reader           StoreReader
}

func NewVulnerabilityProvider(reader StoreReader) (vulnerability.Provider, error) {
	namespaces, err := reader.GetVulnerabilityNamespaces()
	if err != nil {
		return nil, fmt.Errorf("unable to get namespaces from store: %w", err)
	}

	namespaceIndex, err := namespace.FromStrings(namespaces)
	if err != nil {
		return nil, fmt.Errorf("unable to parse namespaces from store: %w", err)
	}

	return &vulnerabilityProvider{
		namespaceIndex:   namespaceIndex,
		metadataProvider: NewVulnerabilityMetadataProvider(reader),
		reader:           reader,
	}, nil
}

func (pr *vulnerabilityProvider) Close() error {
	return pr.reader.Close()
}

func (pr *vulnerabilityProvider) FindVulnerabilities(criteria ...vulnerability.Criteria) ([]vulnerability.Vulnerability, error) {
	searchCrit, unapplied := searchCriteria(criteria)

	var err error
	var vulns []vulnerability.Vulnerability
	switch {
	case searchCrit.ID != "":
		vulns, err = pr.Get(searchCrit.ID, searchCrit.Namespace)
	case searchCrit.Distro != nil:
		vulns, err = pr.GetByDistro(searchCrit.Distro, pkg.Package{
			Name: searchCrit.PackageName,
		})
	case searchCrit.Language != nil:
		vulns, err = pr.GetByLanguage(*searchCrit.Language, pkg.Package{
			Name: searchCrit.PackageName,
		})
	case searchCrit.CPE != nil:
		vulns, err = pr.GetByCPE(*searchCrit.CPE)
	default:
		return nil, fmt.Errorf("unable to find vulnerabilities without distro, language, or CPE: %+v", criteria)
	}

	// apply criteria
	for i := 0; i < len(vulns); i++ {
		v := vulns[i]

		log.Trace(v)

		for _, c := range unapplied {
			if c == nil {
				continue
			}
			matches, err := c.MatchesVulnerability(v)
			if err != nil {
				return nil, err
			}
			if !matches {
				vulns = append(vulns[0:i], vulns[i+1:]...)
				i--
				break
			}
		}
	}
	return vulns, err
}

func (pr *vulnerabilityProvider) VulnerabilityMetadata(ref vulnerability.Reference) (*vulnerability.Metadata, error) {
	return pr.metadataProvider.GetMetadata(ref.ID, ref.Namespace)
}

func (pr *vulnerabilityProvider) Get(id, namespace string) ([]vulnerability.Vulnerability, error) {
	// note: getting a vulnerability record by id doesn't necessarily return a single record
	// since records are duplicated by the set of fixes they have.
	vulns, err := pr.reader.GetVulnerability(namespace, id)
	if err != nil {
		return nil, fmt.Errorf("provider failed to fetch namespace=%q pkg=%q: %w", namespace, id, err)
	}

	var results []vulnerability.Vulnerability
	for _, vuln := range vulns {
		vulnObj, err := NewVulnerability(vuln)
		if err != nil {
			log.WithFields("namespace", vuln.Namespace, "id", vuln.ID).Errorf("failed to inflate vulnerability record: %v", err)
			continue
		}

		results = append(results, *vulnObj)
	}
	return results, nil
}

func (pr *vulnerabilityProvider) GetByDistro(d *distro.Distro, p pkg.Package) ([]vulnerability.Vulnerability, error) {
	if d == nil {
		return nil, nil
	}

	var vulnerabilities []vulnerability.Vulnerability
	namespaces := pr.namespaceIndex.NamespacesForDistro(d)

	if len(namespaces) == 0 {
		log.Debugf("no vulnerability namespaces found in grype database for distro=%s package=%s", d.String(), p.Name)
		return vulnerabilities, nil
	}

	vulnerabilities = make([]vulnerability.Vulnerability, 0)

	for _, n := range namespaces {
		for _, packageName := range n.Resolver().Resolve(p) {
			nsStr := n.String()
			allPkgVulns, err := pr.reader.SearchForVulnerabilities(nsStr, packageName)

			if err != nil {
				return nil, fmt.Errorf("provider failed to search for vulnerabilities (namespace=%q pkg=%q): %w", nsStr, packageName, err)
			}

			for _, vuln := range allPkgVulns {
				vulnObj, err := NewVulnerability(vuln)
				if err != nil {
					log.WithFields("namespace", vuln.Namespace, "id", vuln.ID).Errorf("failed to inflate vulnerability record (by distro): %v", err)
					continue
				}

				vulnerabilities = append(vulnerabilities, *vulnObj)
			}
		}
	}

	return vulnerabilities, nil
}

func (pr *vulnerabilityProvider) GetByLanguage(l syftPkg.Language, p pkg.Package) ([]vulnerability.Vulnerability, error) {
	var vulnerabilities []vulnerability.Vulnerability
	namespaces := pr.namespaceIndex.NamespacesForLanguage(l)

	if len(namespaces) == 0 {
		log.Debugf("no vulnerability namespaces found in grype database for language=%s package=%s", l, p.Name)
		return vulnerabilities, nil
	}

	vulnerabilities = make([]vulnerability.Vulnerability, 0)

	for _, n := range namespaces {
		for _, packageName := range n.Resolver().Resolve(p) {
			nsStr := n.String()
			allPkgVulns, err := pr.reader.SearchForVulnerabilities(nsStr, packageName)

			if err != nil {
				return nil, fmt.Errorf("provider failed to fetch namespace=%q pkg=%q: %w", nsStr, packageName, err)
			}

			for _, vuln := range allPkgVulns {
				vulnObj, err := NewVulnerability(vuln)
				if err != nil {
					log.WithFields("namespace", vuln.Namespace, "id", vuln.ID).Errorf("failed to inflate vulnerability record (by language): %v", err)
					continue
				}

				vulnerabilities = append(vulnerabilities, *vulnObj)
			}
		}
	}

	return vulnerabilities, nil
}

func (pr *vulnerabilityProvider) GetByCPE(requestCPE cpe.CPE) ([]vulnerability.Vulnerability, error) {
	vulns := make([]vulnerability.Vulnerability, 0)
	namespaces := pr.namespaceIndex.CPENamespaces()

	if len(namespaces) == 0 {
		log.Debugf("no vulnerability namespaces found for arbitrary CPEs in grype database")
		return nil, nil
	}

	if requestCPE.Attributes.Product == wfn.Any || requestCPE.Attributes.Product == wfn.NA {
		return nil, fmt.Errorf("product name is required")
	}

	for _, ns := range namespaces {
		allPkgVulns, err := pr.reader.SearchForVulnerabilities(ns.String(), ns.Resolver().Normalize(requestCPE.Attributes.Product))
		if err != nil {
			return nil, fmt.Errorf("provider failed to fetch namespace=%q product=%q: %w", ns, requestCPE.Attributes.Product, err)
		}

		normalizedRequestCPE, err := cpe.New(ns.Resolver().Normalize(requestCPE.Attributes.BindToFmtString()), requestCPE.Source)

		if err != nil {
			normalizedRequestCPE = requestCPE
		}

		for _, vuln := range allPkgVulns {
			vulnCPEs, err := cpeUtil.NewSlice(vuln.CPEs...)
			if err != nil {
				return nil, err
			}

			// compare the request CPE to the potential matches (excluding version, which is handled downstream)
			candidateMatchCpes := cpeUtil.MatchWithoutVersion(normalizedRequestCPE, vulnCPEs)

			if len(candidateMatchCpes) > 0 {
				vulnObj, err := NewVulnerability(vuln)
				if err != nil {
					log.WithFields("namespace", vuln.Namespace, "id", vuln.ID, "cpe", requestCPE.Attributes.BindToFmtString()).Errorf("failed to inflate vulnerability record (by CPE): %v", err)
					continue
				}

				vulnObj.CPEs = candidateMatchCpes

				vulns = append(vulns, *vulnObj)
			}
		}
	}

	return vulns, nil
}

// searchCriteria takes all criteria objects and combines the values into a single
// criteria object to use for vulnerability querying, and a set of criteria that did not apply
// which will be applied after initial database results have been returned
func searchCriteria(allCriteria []vulnerability.Criteria) (criteria, []vulnerability.Criteria) {
	searchCrit := criteria{}
	var unapplied []vulnerability.Criteria
	for _, c := range allCriteria {
		applied := false
		if c, ok := c.(*criteria); ok {
			if searchCrit.Distro == nil && c.Distro != nil {
				searchCrit.Distro = c.Distro
				applied = true
			}
			if searchCrit.Namespace == "" && c.Namespace != "" {
				searchCrit.Namespace = c.Namespace
				applied = true
			}
			if searchCrit.Language == nil && c.Language != nil {
				searchCrit.Language = c.Language
				applied = true
			}
			if searchCrit.CPE == nil && c.CPE != nil {
				searchCrit.CPE = c.CPE
				applied = true
			}
			if searchCrit.PackageName == "" && c.PackageName != "" {
				searchCrit.PackageName = c.PackageName
				applied = true
			}
			if searchCrit.ID == "" && c.ID != "" {
				searchCrit.ID = c.ID
				applied = true
			}
		}
		if !applied {
			unapplied = append(unapplied, c)
		}
	}
	return searchCrit, unapplied
}
