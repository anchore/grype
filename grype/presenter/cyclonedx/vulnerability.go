package cyclonedx

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/CycloneDX/cyclonedx-go"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/vulnerability"
)

// Source: https://cyclonedx.org/ext/vulnerability/

// NewVulnerability creates a Vulnerability document from a match and the metadata provider
func NewVulnerability(m match.Match, p vulnerability.MetadataProvider) (v cyclonedx.Vulnerability, err error) {
	metadata, err := p.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
	if err != nil {
		return v, fmt.Errorf("unable to fetch vuln=%q metadata: %+v", m.Vulnerability.ID, err)
	}

	// The schema does not allow "Negligible", only allowing the following:
	// "unknown", 'none', "info", 'low', 'medium', 'high', 'critical'
	severity := cdxSeverityFromGrypeSeverity(metadata.Severity)

	// Scoring method can be one of the following:
	// "CVSSv2", "CVSSv3", "CVSSv31", "OWASP", "other"

	ratings := []cyclonedx.VulnerabilityRating{
		{
			Source:        nil,
			Score:         nil,
			Severity:      severity,
			Method:        cyclonedx.ScoringMethodOther,
			Vector:        "",
			Justification: "",
		},
	}

	// TODO: pass BOMRef here
	return cyclonedx.Vulnerability{
		BOMRef:         "",
		ID:             m.Vulnerability.ID,
		Source:         nil,
		References:     nil,
		Ratings:        &ratings,
		CWEs:           nil,
		Description:    "",
		Detail:         "",
		Recommendation: "",
		Advisories:     nil,
		Created:        "",
		Published:      "",
		Updated:        "",
		Credits:        nil,
		Tools:          nil,
		Analysis:       nil,
		Affects:        nil,
		Properties:     nil,
	}, nil
}

func makeVulnerabilityURL(id string) string {
	if strings.HasPrefix(id, "CVE-") {
		return fmt.Sprintf("http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s", id)
	}
	if strings.HasPrefix(id, "GHSA") {
		return fmt.Sprintf("https://github.com/advisories/%s", id)
	}
	return id
}

// cvssVersionToMethod accepts a CVSS version as string (e.g. "3.1") and converts it to a
// CycloneDx rating Method, for example "CVSSv3"
func cvssVersionToMethod(version string) (string, error) {
	value, err := strconv.ParseFloat(version, 64)
	if err != nil {
		return "", err
	}

	switch int(value) {
	case 2:
		return "CVSSv2", nil
	case 3:
		return "CVSSv3", nil
	default:
		return "", fmt.Errorf("unable to parse %s into a CVSS version", version)
	}
}

func cdxSeverityFromGrypeSeverity(severity string) cyclonedx.Severity {
	switch severity {
	case "Negligible":
		return cyclonedx.SeverityNone
	case "Unknown":
		return cyclonedx.SeverityUnknown
	case "Info":
		return cyclonedx.SeverityInfo
	case "Low":
		return cyclonedx.SeverityLow
	case "Medium":
		return cyclonedx.SeverityMedium
	case "High":
		return cyclonedx.SeverityHigh
	case "Critical":
		return cyclonedx.SeverityCritical
	default:
		return cyclonedx.SeverityUnknown
	}
}
