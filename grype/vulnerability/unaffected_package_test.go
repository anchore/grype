package vulnerability

import (
	"testing"

	"github.com/anchore/grype/grype/version"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnaffectedPackage_Matches_VersionContains(t *testing.T) {
	tests := []struct {
		name           string
		constraint     string
		packageVersion string
		versionFormat  version.Format
		expectedMatch  bool
		expectError    bool
	}{
		{
			name:           "Debian with .root.io suffix - matches",
			constraint:     "version_contains .root.io",
			packageVersion: "1.5.2-6+deb12u1.root.io.4",
			versionFormat:  version.DebFormat,
			expectedMatch:  true,
		},
		{
			name:           "Ubuntu with .root.io suffix - matches",
			constraint:     "version_contains .root.io",
			packageVersion: "2.3.4-1ubuntu1.root.io.2",
			versionFormat:  version.DebFormat,
			expectedMatch:  true,
		},
		{
			name:           "Alpine with .root.io suffix - matches",
			constraint:     "version_contains .root.io",
			packageVersion: "3.0.8-r3.root.io.1",
			versionFormat:  version.ApkFormat,
			expectedMatch:  true,
		},
		{
			name:           "Alpine with -rXX007X pattern - matches",
			constraint:     "version_contains .root.io",
			packageVersion: "3.0.8-r00071",
			versionFormat:  version.ApkFormat,
			expectedMatch:  true,
		},
		{
			name:           "Alpine with -r10074 pattern - matches",
			constraint:     "version_contains .root.io",
			packageVersion: "1.6.17-r10074",
			versionFormat:  version.ApkFormat,
			expectedMatch:  true,
		},
		{
			name:           "Alpine with -r20075 pattern - matches",
			constraint:     "version_contains .root.io",
			packageVersion: "2.1.0-r20075",
			versionFormat:  version.ApkFormat,
			expectedMatch:  true,
		},
		{
			name:           "Alpine regular version - does not match",
			constraint:     "version_contains .root.io",
			packageVersion: "3.0.8-r3",
			versionFormat:  version.ApkFormat,
			expectedMatch:  false,
		},
		{
			name:           "Alpine with -r3 (no 007) - does not match",
			constraint:     "version_contains .root.io",
			packageVersion: "3.0.8-r3",
			versionFormat:  version.ApkFormat,
			expectedMatch:  false,
		},
		{
			name:           "Alpine with -r1234 (no 007) - does not match",
			constraint:     "version_contains .root.io",
			packageVersion: "3.0.8-r1234",
			versionFormat:  version.ApkFormat,
			expectedMatch:  false,
		},
		{
			name:           "Debian regular version - does not match",
			constraint:     "version_contains .root.io",
			packageVersion: "1.5.2-6+deb12u1",
			versionFormat:  version.DebFormat,
			expectedMatch:  false,
		},
		{
			name:           "Alpine pattern only applies to APK format",
			constraint:     "version_contains .root.io",
			packageVersion: "1.0.0-r00071",
			versionFormat:  version.DebFormat,
			expectedMatch:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			up := UnaffectedPackage{
				CVE:        "CVE-2024-1234",
				Package:    "test-package",
				Constraint: tt.constraint,
			}

			matched, err := up.Matches(tt.packageVersion, tt.versionFormat)

			if tt.expectError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expectedMatch, matched,
					"Expected match=%v for version %s with constraint %s",
					tt.expectedMatch, tt.packageVersion, tt.constraint)
			}
		})
	}
}

func TestUnaffectedPackage_Matches_VersionConstraint(t *testing.T) {
	tests := []struct {
		name           string
		constraint     string
		packageVersion string
		versionFormat  version.Format
		expectedMatch  bool
	}{
		{
			name:           "Greater than or equal - matches",
			constraint:     ">= 3.0.8-r4",
			packageVersion: "3.0.9-r1",
			versionFormat:  version.ApkFormat,
			expectedMatch:  true,
		},
		{
			name:           "Greater than or equal - equal matches",
			constraint:     ">= 3.0.8-r4",
			packageVersion: "3.0.8-r4",
			versionFormat:  version.ApkFormat,
			expectedMatch:  true,
		},
		{
			name:           "Greater than or equal - less than does not match",
			constraint:     ">= 3.0.8-r4",
			packageVersion: "3.0.8-r3",
			versionFormat:  version.ApkFormat,
			expectedMatch:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			up := UnaffectedPackage{
				CVE:        "CVE-2024-1234",
				Package:    "test-package",
				Constraint: tt.constraint,
			}

			matched, err := up.Matches(tt.packageVersion, tt.versionFormat)
			require.NoError(t, err)
			assert.Equal(t, tt.expectedMatch, matched)
		})
	}
}

func TestAlpineRootIOPattern(t *testing.T) {
	tests := []struct {
		version      string
		shouldMatch  bool
		description  string
	}{
		{"3.0.8-r00071", true, "Basic -r00071 pattern"},
		{"1.6.17-r10074", true, "Pattern with higher first digit"},
		{"2.1.0-r20075", true, "Pattern with 2 as first digit"},
		{"3.0.8-r99079", true, "Pattern with 99 prefix"},
		{"3.0.8-r3", false, "Regular release number"},
		{"3.0.8-r1234", false, "No 007 in pattern"},
		{"3.0.8-r007", false, "Too short"},
		{"3.0.8-r0071", false, "Only 4 digits total (needs 5+)"},
		{"3.0.8-r0007", false, "007 at wrong position"},
		{"3.0.8-r12345", false, "No 007 anywhere"},
	}

	for _, tt := range tests {
		t.Run(tt.description, func(t *testing.T) {
			matched := alpineRootIOPattern.MatchString(tt.version)
			assert.Equal(t, tt.shouldMatch, matched,
				"Version %s should match=%v: %s", tt.version, tt.shouldMatch, tt.description)
		})
	}
}
