package vulnerability

// NewMockProvider returns a new mock implementation of a vulnerability Provider, with the provided set of vulnerabilities
func NewMockProvider(vulnerabilities ...Vulnerability) Provider {
	return &mockProvider{
		Vulnerabilities: vulnerabilities,
	}
}

type mockProvider struct {
	Vulnerabilities []Vulnerability
}

func (s *mockProvider) Close() error {
	return nil
}

// VulnerabilityMetadata returns the metadata associated with a vulnerability
func (s *mockProvider) VulnerabilityMetadata(ref Reference) (*Metadata, error) {
	for _, vuln := range s.Vulnerabilities {
		if vuln.ID == ref.ID && vuln.Namespace == ref.Namespace {
			var meta *Metadata
			if m, ok := vuln.Reference.Internal.(Metadata); ok {
				meta = &m
			}
			if m, ok := vuln.Reference.Internal.(*Metadata); ok {
				meta = m
			}
			if meta != nil {
				if meta.ID != vuln.ID {
					meta.ID = vuln.ID
				}
				if meta.Namespace != vuln.Namespace {
					meta.Namespace = vuln.Namespace
				}
				return meta, nil
			}
		}
	}
	return nil, nil
}

func (s *mockProvider) FindVulnerabilities(criteria ...Criteria) ([]Vulnerability, error) {
	var out []Vulnerability
	out = append(out, s.Vulnerabilities...)
	return filterE(out, func(v Vulnerability) (bool, error) {
		for _, c := range criteria {
			matches, err := c.MatchesVulnerability(v)
			if err != nil {
				return false, err
			}
			if !matches {
				return false, nil
			}
		}
		return true, nil
	})
}

func filterE[T any](out []T, keep func(v T) (bool, error)) ([]T, error) {
	for i := 0; i < len(out); i++ {
		ok, err := keep(out[i])
		if err != nil {
			return nil, err
		}
		if !ok {
			out = append(out[:i], out[i+1:]...)
			i--
		}
	}
	return out, nil
}
