# Grype Templates

This folder contains a set of "helper" go templates you can use for your own reports.

Please feel free to extend and/or update the templates for your needs, be sure to contribute back into this folder any new templates!

Current templates:

<pre>
.
├── README.md
├── csv.tmpl
├── html.tmpl
├── json_mapping.tmpl
├── junit.tmpl
└── table.tmpl
</pre>

## Table

This template mimics the "default" table output of Grype, there are some drawbacks to using the template vs the native output such as:

- unsorted
- duplicate rows
- no (wont-fix) logic

As you can see from the above list, it's not perfect but it's a start.

## HTML

Produces a nice html report with a dynamic table using datatables.js.

You can also modify the templating filter to limit the output to a subset.

Default includes all

```golang
    {{- if or (eq $vuln.Vulnerability.Severity "Critical") (eq $vuln.Vulnerability.Severity "High") (eq $vuln.Vulnerability.Severity "Medium") (eq $vuln.Vulnerability.Severity "Low") (eq $vuln.Vulnerability.Severity "Unknown") }}
```

We can limit it to only Critical, High, and Medium by editing the filter as follows

```golang
    {{- if or (eq $vuln.Vulnerability.Severity "Critical") (eq $vuln.Vulnerability.Severity "High") (eq $vuln.Vulnerability.Severity "Medium") }}
```

## JSON Mapping

This template is **NOT** intended as a standard output format. Its primary purpose is to serve as a **reference guide for developers** creating custom Grype templates.

It demonstrates how to access various fields from the underlying Go data structures (primarily `presenter/models.Document`) within a Go `text/template` context. It aims to produce output that closely resembles the standard `grype -o json` format, but using template syntax.

Use this template to understand the available fields and how they map from the Go structs when writing your own custom templates. Be aware that the output generated by this template **will not be byte-for-byte identical** to the standard `grype -o json` output due to fundamental differences between Go's `text/template` rendering and `encoding/json` serialization:

1. **Field Names vs. JSON Tags** 

    Templates access data using the Go struct field names (e.g., `.Match.Artifact.Name`). The standard JSON output uses keys determined by `json:"..."` tags defined on the Go structs, which may differ from the field names (e.g., a Go field `InputDigest` might become the key `"input"` in the JSON output).

2. **`interface{}` and Map/Slice Rendering**

    Fields defined as `interface{}` in the Go structs (e.g., `.MatchDetails.SearchedBy`, `.MatchDetails.Found`, `.Artifact.Metadata`) often hold map or slice data.

    Then directly rendering these using `{{ .FieldName }}` in a template, Go's default string representation is typically used (e.g., `map[key:value ...]`). The standard JSON output correctly serializes these into standard JSON object (`{ "key": "value", ... }`) or array (`[ ... ]`) syntax.

3. **Nil vs. Empty Collections**

    The standard JSON output might omit empty slices or maps if the corresponding Go struct field has an `omitempty` tag. Template rendering might explicitly show `[]` or `map[]` depending on the underlying data.

4. **Time Formatting**

    Standard JSON output typically uses RFC3339 or RFC3339Nano format for timestamps. Direct rendering of `time.Time` objects in templates might use a different default format unless explicitly formatted within the template.
